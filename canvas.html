<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <canvas width="500" height="500" id="canvas" style="border: 2px solid black"></canvas>

  <label for="">Drawing Mode</label>
  <input type="checkbox" onchange="toggleDrawMode()">

  <script>

    function toggleDrawMode() {
      isDrawingMode = !isDrawingMode
    }

    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    let lines = [];

    const viewportTransform = {
      x: 0,
      y: 0,
      scale: 1
    }

    // From here on, everything we'll write will go below ðŸ‘‡
    const drawRect = (x, y, width, height, color) => {
      ctx.fillStyle = color
      ctx.fillRect(x, y, width, height)
    }


    let isDrawingMode = false
    const penWidth = 5
    const penColor = 'red'

    const drawPixels = (x, y) => {
      ctx.beginPath()

      ctx.arc(x, y, penWidth, 2 * Math.PI, false)
      ctx.fillStyle = penColor

      ctx.fill()
    }

    const erasePixels = (x, y) => {
      ctx.save()

      ctx.beginPath()
      ctx.arc(x, y, penWidth, 2 * Math.PI, false)

      ctx.globalCompositeOperation = 'destination-out'

      ctx.fillStyle = 'white'
      ctx.fill()
      ctx.restore()
    }


    const render = () => {

      // New code ðŸ‘‡
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(viewportTransform.scale, 0, 0, viewportTransform.scale, viewportTransform.x, viewportTransform.y);
      // New Code ðŸ‘†

      // drawRect(0, 0, 100, 100, 'red');
      // drawRect(200, 200, 100, 100, 'blue');
      // drawPixels(400, 400)

      // Ok, so we DO need to redraw the lines. That means we DO need to KEEP TRACK of them!
      // This drawing just needs absolute figures, the same as they were when the line was being made! The viewportTransform will automatically adjust shit here and there.
      lines.forEach(line => {

        console.log('letsdraw this line', line);

        drawPixels(line.x, line.y)
      });

    }


    render()
    drawPixels(400, 400)
    lines.push({ x: 400, y: 400 })


    // We need to keep track of our previous mouse position for later
    let previousX = 0, previousY = 0;

    const updatePanning = (e) => {
      const localX = e.clientX;
      const localY = e.clientY;

      viewportTransform.x += localX - previousX;
      viewportTransform.y += localY - previousY;

      previousX = localX;
      previousY = localY;
    }

    const updateZooming = (e) => {
      const oldScale = viewportTransform.scale;
      const oldX = viewportTransform.x;
      const oldY = viewportTransform.y;

      const localX = e.clientX;
      const localY = e.clientY;

      const previousScale = viewportTransform.scale;

      const newScale = viewportTransform.scale += e.deltaY * -0.01;

      const newX = localX - (localX - oldX) * (newScale / previousScale);
      const newY = localY - (localY - oldY) * (newScale / previousScale);

      viewportTransform.x = newX;
      viewportTransform.y = newY;
      viewportTransform.scale = newScale;
    }


    const drawLine = (x, y) => {
      ctx.beginPath()
      ctx.moveTo(previousX, previousY)
      ctx.lineTo(x, y)

      ctx.strokeStyle = penColor
      ctx.lineWidth = penWidth
      ctx.lineCap = 'round'

      ctx.stroke()
    }

    const eraseLine = (x, y) => {
      ctx.save()

      ctx.beginPath()
      ctx.moveTo(previousX, previousY)
      ctx.lineTo(x, y)

      ctx.globalCompositeOperation = 'destination-out'

      ctx.strokeStyle = 'white'
      ctx.lineWidth = penWidth
      ctx.lineCap = 'round'

      ctx.stroke()
      ctx.restore()
    }


    const onMouseMove = (e) => {

      // Handle the case of drawing here. If drawing mode is on, then that should be handled.

      if (isDrawingMode) {
        // FINAL: yes this is the final solution! I have got it! Eureka!!!! yippieee
        const adjustedX = e.offsetX * viewportTransform.scale - viewportTransform.x;
        const adjustedY = e.offsetY * viewportTransform.scale - viewportTransform.y;

        const xToDraw = adjustedX
        const yToDraw = adjustedY

        if (e.shiftKey) {
          erasePixels(xToDraw, yToDraw)
          lines.push({ x: xToDraw, y: yToDraw }) // TODO: of course we somehow need to remember that this is a erased line. and handle it that way
        } else {

          drawPixels(xToDraw, yToDraw)
          lines.push({ x: xToDraw, y: yToDraw })

          
        }


      } else {
        updatePanning(e)
        render()
      }

      // updatePanning(e)
      // render()

      console.log(e)
    }

    const onMouseWheel = (e) => {
      updateZooming(e)

      render()

      console.log(e)
    }

    canvas.addEventListener("wheel", onMouseWheel);


    canvas.addEventListener("mousedown", (e) => {
      previousX = e.clientX;
      previousY = e.clientY;

      canvas.addEventListener("mousemove", onMouseMove);
    })

    canvas.addEventListener("mouseup", (e) => {
      canvas.removeEventListener("mousemove", onMouseMove);
    })


  </script>
</body>

</html>