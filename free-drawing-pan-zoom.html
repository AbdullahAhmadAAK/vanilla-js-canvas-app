<html>

<body>
  <canvas width="500" height="500" id="canvas"></canvas>

  <button id="blue-button">Blue</button>
  <button id="red-button">Red</button>

  <button id="toggler">Toggle Drawing Mode:</button>
  <span id="drawing-mode-value"></span>


  <script>
    let previousX = 0
    let previousY = 0

    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')

    const viewportTransform = {
      x: 0,
      y: 0,
      scale: 1
    }

    const blueButton = document.getElementById('blue-button')
    blueButton.addEventListener('click', () => {
      penColor = 'blue'
    })

    const redButton = document.getElementById('red-button')
    redButton.addEventListener('click', () => {
      penColor = 'red'
    })

    let isDrawingMode = true

    const togglerDrawingMode = document.getElementById('toggler')
    togglerDrawingMode.addEventListener('click', () => {
      isDrawingMode = !isDrawingMode

      drawingModeSpanElement.innerHTML = isDrawingMode ? 'true' : 'false'
      
      console.log('Is drawing mode on now?', isDrawingMode)
    })

    const drawingModeSpanElement = document.getElementById('drawing-mode-value')
    drawingModeSpanElement.innerHTML = isDrawingMode ? 'true' : 'false'

    let penColor = 'red'
    let penWidth = 5

    // Your code here ðŸ‘‡
    const drawPixels = (x, y) => {
      ctx.beginPath()

      ctx.arc(x, y, penWidth, 2 * Math.PI, false)
      ctx.fillStyle = penColor

      ctx.fill()
    }

    // const erasePixelsTest = (x, y) => {
    //   ctx.beginPath()

    //   ctx.arc(x, y, penWidth, 2 * Math.PI, false)
    //   ctx.fillStyle = penColor

    //   ctx.fill()
    // }

    const erasePixels = (x, y) => {
      ctx.save()

      ctx.beginPath()
      ctx.arc(x, y, penWidth, 2 * Math.PI, false)

      ctx.globalCompositeOperation = 'destination-out'

      ctx.fillStyle = 'white'
      ctx.fill()
      ctx.restore()
    }


    const drawLine = (x, y) => {
      // OLD CODDE

      // ctx.beginPath()
      // ctx.moveTo(previousX, previousY)
      // ctx.lineTo(x, y)

      // ctx.strokeStyle = penColor
      // ctx.lineWidth = penWidth
      // ctx.lineCap = 'round'

      // ctx.stroke()

      // Adjust coordinates to account for the zoom and pan transform
      const adjustedX = (x - viewportTransform.x) / viewportTransform.scale;
      const adjustedY = (y - viewportTransform.y) / viewportTransform.scale;

      const adjustedPrevX = (previousX - viewportTransform.x) / viewportTransform.scale;
      const adjustedPrevY = (previousY - viewportTransform.y) / viewportTransform.scale;

      // Use the adjusted coordinates for drawing
      ctx.beginPath();
      ctx.moveTo(adjustedPrevX, adjustedPrevY);
      ctx.lineTo(adjustedX, adjustedY);

      ctx.strokeStyle = penColor;
      ctx.lineWidth = penWidth / viewportTransform.scale; // Scale line width for zoom consistency
      ctx.lineCap = 'round';

      ctx.stroke();

      // Update previous coordinates for the next line segment
      previousX = x;
      previousY = y;

    }

    const eraseLine = (x, y) => {
      // OLD CODE
      // ctx.save()
      // ctx.beginPath()
      // ctx.moveTo(previousX, previousY)
      // ctx.lineTo(x, y)
      // ctx.globalCompositeOperation = 'destination-out'
      // ctx.strokeStyle = 'white'
      // ctx.lineWidth = penWidth
      // ctx.lineCap = 'round'
      // ctx.stroke()
      // ctx.restore()

      ctx.save();

      // Adjust coordinates to account for the zoom and pan transform
      const adjustedX = (x - viewportTransform.x) / viewportTransform.scale;
      const adjustedY = (y - viewportTransform.y) / viewportTransform.scale;

      const adjustedPrevX = (previousX - viewportTransform.x) / viewportTransform.scale;
      const adjustedPrevY = (previousY - viewportTransform.y) / viewportTransform.scale;

      // Use the adjusted coordinates for erasing
      ctx.beginPath();
      ctx.moveTo(adjustedPrevX, adjustedPrevY);
      ctx.lineTo(adjustedX, adjustedY);

      ctx.globalCompositeOperation = 'destination-out'; // Erase instead of drawing
      ctx.strokeStyle = 'white'; // Color doesn't matter in this mode
      ctx.lineWidth = penWidth / viewportTransform.scale; // Scale line width for zoom consistency
      ctx.lineCap = 'round';

      ctx.stroke();
      ctx.restore();

      // Update previous coordinates for the next erase segment
      previousX = x;
      previousY = y;
    };

    // End of your code ðŸ‘†


    const render = (e) => {
      // Just to see whether this scales on panning/zooming. can remove this.
      // drawRect(0, 0, 100, 100, 'red');

      // NEW CODE

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      // ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(viewportTransform.scale, 0, 0, viewportTransform.scale, viewportTransform.x, viewportTransform.y);

      // NEW CODE ENDS HERE!
      if (e.type === 'mousemove' && isDrawingMode) {
        const x = e.offsetX
        const y = e.offsetY

        console.log(`Drawing at (${x}, ${y})`, e)

        if (e.shiftKey) {
          // erasePixels(x, y)
          eraseLine(x, y)
        } else {
          // drawPixels(x, y)
          drawLine(x, y)
        }

        previousX = x
        previousY = y
      }




    }

    const drawRect = (x, y, width, height, color) => {
      ctx.fillStyle = color
      ctx.fillRect(x, y, width, height)
    }

    // BRAND NEW CODE FOR PANZOOM
    const updatePanning = (e) => {
      const localX = e.clientX;
      const localY = e.clientY;

      viewportTransform.x += localX - previousX;
      viewportTransform.y += localY - previousY;

      previousX = localX;
      previousY = localY;
    }

    const updateZooming = (e) => {
      const oldScale = viewportTransform.scale;
      const oldX = viewportTransform.x;
      const oldY = viewportTransform.y;

      const localX = e.clientX;
      const localY = e.clientY;

      const previousScale = viewportTransform.scale;

      const newScale = viewportTransform.scale += e.deltaY * -0.01;

      const newX = localX - (localX - oldX) * (newScale / previousScale);
      const newY = localY - (localY - oldY) * (newScale / previousScale);

      viewportTransform.x = newX;
      viewportTransform.y = newY;
      viewportTransform.scale = newScale;
    }

    const onMouseMove = (e) => {
      updatePanning(e)
      render(e)

      console.log(e)
    }

    const onMouseWheel = (e) => {
      updateZooming(e)

      render(e)

      console.log('onMouseWheel happened: ', e)
    }

    canvas.addEventListener("wheel", onMouseWheel);

    canvas.addEventListener('mousedown', (e) => {
      previousX = e.offsetX
      previousY = e.offsetY

      canvas.addEventListener('mousemove', onMouseMove)

      canvas.addEventListener('mouseup', () => {
        canvas.removeEventListener('mousemove', onMouseMove)
      })
    })

  </script>
</body>

</html>